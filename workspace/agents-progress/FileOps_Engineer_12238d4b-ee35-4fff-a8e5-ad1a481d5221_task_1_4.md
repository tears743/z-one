工作区当前**不存在** `glod.md`（`file_exists=false`）。

## 覆盖/新建策略（幂等）
- **路径规范**：目标文件固定为工作区根目录相对路径 `glod.md`（避免多处同名导致非幂等）。
- **写入语义**：采用“**最终一次性覆盖写入**”策略：
  - 若文件不存在：创建并写入完整内容；
  - 若文件已存在：不做增量 append，始终用同一份最终内容 **overwrite**，保证重复执行结果一致（幂等）。
- **失败不污染原则**：在最终写入前不触碰 `glod.md`，避免中途异常留下半成品。

## 分段写入方案（临时缓冲 → 最终覆盖）
1. **临时缓冲（内存/分段组装）**
   - 将内容按段落/章节拆为 `segments[]`（每段为字符串）。
   - 只在内存中拼接：`final_content = ''.join(segments)`  
   - 统一换行规范：推荐 `\n`；段与段之间明确插入 `\n\n`（可控、可复现）。

2. **最终一次性覆盖写入**
   - 直接对 `glod.md` 执行一次 `write_file(path="glod.md", content=final_content)`。
   - 不使用多次 `write_file` 追加式写入（避免部分写入成功、部分失败导致文件处于不可预期状态）。

3. **回读校验（写后读一致性）**
   - 写入后立即 `read_file("glod.md")`，校验：
     - **全量一致**：回读内容应与 `final_content` 字符串完全相等；
     - 若不相等：视为写入异常/并发污染，触发错误处理（见下）。

## 异常处理建议
- **写入失败/回读不一致**：
  - 记录错误（失败原因、预期长度/实际长度、首尾片段用于定位）。
  - 不进行“自动追加修复”，而是重新生成 `final_content` 后再次执行“单次覆盖写入 + 回读校验”（确保幂等）。
- **并发风险**（若存在多个流程写同一文件）：
  - 通过上层流程保证串行；否则使用外部锁/单 writer 约束（本工具集不提供锁原语）。

如需我按该方案实际创建 `glod.md`（写入一个模板骨架）并做回读校验，告诉我内容结构/段落清单即可。